import path from 'node:path';
import assert from 'node:assert';
import webpack from 'webpack';
import { Rule, WebpackPlugin } from '../../types';
import { AssetsCopyProcessor } from './utils/AssetsCopyProcessor';
import { AuxiliaryAssetsCopyProcessor } from './utils/AuxiliaryAssetsCopyProcessor';

/**
 * Matching options to check if given {@link DestinationConfig} should be used.
 */
export type DestinationMatchRules = {
  /**
   * Rule (string or RegExp) that must match the chunk name (or id if name is not available),
   * for the whole `DestinationMatchRules` to match.
   */
  test?: Rule | Rule[];

  /**
   * Rule (string or RegExp) that must match the chunk name (or id if name is not available),
   * for the whole `DestinationMatchRules` to match.
   */
  include?: Rule | Rule[];

  /**
   * Rule (string or RegExp) that __MUST NOT__ match the chunk name (or id if name is not available),
   * for the whole `DestinationMatchRules` to match.
   */
  exclude?: Rule | Rule[];
};

/**
 * Destination config for local chunks.
 */
export type LocalDestinationConfig = {
  type: 'local';
};

/**
 * Destination config for remote chunks.
 */
export type RemoteDestinationConfig = {
  type: 'remote';

  /** Output path to a directory, where remote chunks should be saved. */
  outputPath: string;
};

/**
 * Destination config for chunks.
 */
export type DestinationConfig =
  | LocalDestinationConfig
  | RemoteDestinationConfig;

/**
 * Destination specification for chunks.
 */
export type DestinationSpec = DestinationMatchRules & DestinationConfig;

/**
 * {@link OutputPlugin} configuration options.
 */
export interface OutputPluginConfig {
  /** Context in which all resolution happens. Usually it's project root directory. */
  context: string;

  /** Target application platform. */
  platform: string;

  /**
   * Whether the plugin is enabled. Defaults to `true`.
   *
   * Useful when running with development server, in which case, it's not necessary for this plugin
   * to be enabled.
   */
  enabled?: boolean;

  /** The entry chunk name, `main` by default. */
  entryName?: string;

  /**
   * Output options specifying where to save generated bundle, source map and assets.
   */
  output: {
    /** Bundle output filename - name under which generated bundle will be saved. */
    bundleFilename?: string;

    /**
     * Source map filename - name under which generated source map (for the main bundle) will be saved.
     */
    sourceMapFilename?: string;

    /** Assets output path - directory where generated static assets will be saved. */
    assetsPath?: string;

    /**
     * Auxiliary assets output path - directory where generated auxiliary assets will be saved
     *
     * Useful when working with remote-assets generated by assetsLoader
     * */
    auxiliaryAssetsPath?: string;
  };

  /**
   * Options specifying how to deal with extra chunks generated in the compilation,
   * usually by using dynamic `import(...)` function.
   *
   * By default all extra chunks will be saved under `<projectRoot>/build/outputs/<platform>/remotes` directory.
   *
   * __Specifying custom value for this option, will disable default setting - you will need
   * to configure `outputPath` for `type: 'remote'` yourself.__
   *
   * If you want to have some of the chunks available inside the `.ipa`/`.apk` file generated by React Native,
   * you must configure this options to match the chunks you want (using `test`/`include`/`exclude`)
   * and set the `type` to `local`, for example:
   * ```ts
   * new OutputPlugin({
   *   context,
   *   platform,
   *   output,
   *   extraChunks: [
   *     {
   *       // Make `my-chunk` local
   *       include: /my-chunk/,
   *       type: 'local',
   *     },
   *     {
   *       // Make any other chunk remote
   *       exclude: /my-chunk/,
   *       type: 'remote',
   *       outputPath,
   *     },
   *   ]
   * });
   * ```
   */
  extraChunks?: DestinationSpec[];
}

/**
 * Plugin for copying generated files (bundle, chunks, assets) from Webpack's built location to the
 * React Native application directory, so that the files can be packed together into the `ipa`/`apk`.
 *
 * @category Webpack Plugin
 */
export class OutputPlugin implements WebpackPlugin {
  /**
   * Constructs new `OutputPlugin`.
   *
   * @param config Plugin configuration options.
   */
  constructor(private config: OutputPluginConfig) {
    this.config.enabled = this.config.enabled ?? true;
    this.config.extraChunks = this.config.extraChunks ?? [
      {
        include: /.*/,
        type: 'remote',
        outputPath: path.join(
          this.config.context,
          'build/outputs',
          this.config.platform,
          'remotes'
        ),
      },
    ];
  }

  private matchChunkToSpecs(
    chunk: webpack.StatsChunk,
    specs: DestinationSpec[]
  ) {
    const chunkIds = [chunk.names ?? [], chunk.id!].flat();
    return specs.filter((spec) => {
      const { test, include, exclude } = spec;
      const config = { test, include, exclude };
      return chunkIds.some((id) =>
        webpack.ModuleFilenameHelpers.matchObject(config, id.toString())
      );
    });
  }

  private getRelatedSourceMap(chunk: webpack.StatsChunk) {
    return chunk.auxiliaryFiles?.find((file) => /\.map$/.test(file));
  }
  /**
   * Apply the plugin.
   *
   * @param compiler Webpack compiler instance.
   */
  apply(compiler: webpack.Compiler) {
    if (!this.config.enabled) return;

    assert(this.config.platform, 'Missing `platform` option in `OutputPlugin`');
    assert(this.config.output, 'Missing `output` option in `OutputPlugin`');
    assert(compiler.options.output.path, "Can't infer output path from config");

    const logger = compiler.getInfrastructureLogger('RepackOutputPlugin');
    const outputPath = compiler.options.output.path as string;
    const nativeEntryChunkName = this.config.entryName ?? 'main';

    // Split specs into types
    const localSpecs: DestinationSpec[] = [];
    const remoteSpecs: DestinationSpec[] = [];

    this.config.extraChunks?.forEach((spec) => {
      if (spec.type === 'local') localSpecs.push(spec);
      if (spec.type === 'remote') remoteSpecs.push(spec);
    });

    const localChunks = new Set<webpack.StatsChunk>();
    const remoteChunks = new Set<webpack.StatsChunk>();
    const auxiliaryAssets = new Set<string>();

    compiler.hooks.done.tapPromise('RepackOutputPlugin', async (stats) => {
      const compilationStats = stats.toJson({
        all: false,
        assets: true,
        chunks: true,
        chunkRelations: true,
        ids: true,
      });

      const chunks = compilationStats.chunks!;
      const assets = compilationStats.assets!;

      const chunksById = new Map(chunks.map((chunk) => [chunk.id!, chunk]));

      // Add explicitly known initial chunks as local chunks
      chunks
        .filter((chunk) => chunk.initial && chunk.entry)
        .filter((chunk) => chunk.id! in compiler.options.entry)
        .forEach((chunk) => localChunks.add(chunk));

      // Add siblings of known initial chunks as local chunks
      chunks
        .filter((chunk) => localChunks.has(chunk))
        .flatMap((chunk) => chunk.siblings!)
        .map((chunkId) => chunksById.get(chunkId))
        .forEach((chunk) => localChunks.add(chunk!));

      // Add chunks matching local specs as local chunks
      chunks
        .filter((chunk) => this.matchChunkToSpecs(chunk, localSpecs).length)
        .forEach((chunk) => localChunks.add(chunk));

      // Add parents of local chunks as local chunks
      const addParentsOfLocalChunks = () => {
        chunks
          .filter((chunk) => localChunks.has(chunk))
          .flatMap((chunk) => chunk.parents!)
          .map((chunkId) => chunksById.get(chunkId))
          .forEach((chunk) => localChunks.add(chunk!));
        return localChunks.size;
      };

      // Iterate until no new chunks are added
      while (localChunks.size - addParentsOfLocalChunks());

      // Add all other chunks as remote chunks
      chunks
        .filter((chunk) => !localChunks.has(chunk))
        .forEach((chunk) => remoteChunks.add(chunk));

      // Collect auxiliary assets (only remote-assets for now)
      assets
        .filter((asset) => /^remote-assets/.test(asset.name))
        .forEach((asset) => auxiliaryAssets.add(asset.name));

      let localAssetsCopyProcessor;
      let { bundleFilename, sourceMapFilename, assetsPath } =
        this.config.output;

      if (bundleFilename) {
        if (!path.isAbsolute(bundleFilename)) {
          bundleFilename = path.join(this.config.context, bundleFilename);
        }

        const bundlePath = path.dirname(bundleFilename);

        if (!sourceMapFilename) {
          sourceMapFilename = `${bundleFilename}.map`;
        }

        if (!path.isAbsolute(sourceMapFilename)) {
          sourceMapFilename = path.join(this.config.context, sourceMapFilename);
        }

        if (!assetsPath) {
          assetsPath = bundlePath;
        }

        logger.debug('Detected output paths:', {
          bundleFilename,
          bundlePath,
          sourceMapFilename,
          assetsPath,
        });

        localAssetsCopyProcessor = new AssetsCopyProcessor({
          platform: this.config.platform,
          outputPath,
          bundleOutput: bundleFilename,
          bundleOutputDir: bundlePath,
          sourcemapOutput: sourceMapFilename,
          assetsDest: assetsPath,
          logger,
        });
      }

      const remoteAssetsCopyProcessors: Record<string, AssetsCopyProcessor> =
        {};

      for (const chunk of localChunks) {
        // Process entry chunk - only one entry chunk is allowed here
        localAssetsCopyProcessor?.enqueueChunk(chunk, {
          isEntry: chunk.id! === nativeEntryChunkName,
          sourceMapFile: this.getRelatedSourceMap(chunk),
        });
      }

      for (const chunk of remoteChunks) {
        const specs = this.matchChunkToSpecs(chunk, remoteSpecs);

        if (specs.length === 0) {
          throw new Error(`No spec found for chunk ${chunk.id}`);
        }
        if (specs.length > 1) {
          logger.warn(`Multiple specs found for chunk ${chunk.id}`);
        }

        const spec = specs[0] as { outputPath: string };
        if (!remoteAssetsCopyProcessors[spec.outputPath]) {
          remoteAssetsCopyProcessors[spec.outputPath] = new AssetsCopyProcessor(
            {
              platform: this.config.platform,
              outputPath,
              bundleOutput: '',
              bundleOutputDir: spec.outputPath,
              sourcemapOutput: '',
              assetsDest: spec.outputPath,
              logger,
            }
          );
        }

        remoteAssetsCopyProcessors[spec.outputPath].enqueueChunk(chunk, {
          isEntry: false,
          sourceMapFile: this.getRelatedSourceMap(chunk),
        });
      }

      let auxiliaryAssetsCopyProcessor;
      const { auxiliaryAssetsPath } = this.config.output;
      if (auxiliaryAssetsPath) {
        auxiliaryAssetsCopyProcessor = new AuxiliaryAssetsCopyProcessor({
          platform: this.config.platform,
          outputPath,
          assetsDest: auxiliaryAssetsPath,
          logger,
        });

        for (const asset of auxiliaryAssets) {
          auxiliaryAssetsCopyProcessor.enqueueAsset(asset);
        }
      }

      await Promise.all([
        ...(localAssetsCopyProcessor?.execute() ?? []),
        ...Object.values(remoteAssetsCopyProcessors).reduce(
          (acc, processor) => acc.concat(...processor.execute()),
          [] as Promise<void>[]
        ),
        ...(auxiliaryAssetsCopyProcessor?.execute() ?? []),
      ]);
    });
  }
}
